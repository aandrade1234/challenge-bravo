package server

import (
	"bytes"
	"challenge-bravo/dao"
	"challenge-bravo/model"
	"encoding/json"
	"github.com/gofiber/fiber/v2"
	"strings"
)

type SuccessResponse struct {
	Success bool `json:"success"`
}

// NewCurrency Creates a new currency
// @Summary      Creates a new currency
// @Description  Execute a custom currency creation
// @Tags         currency
// @Accept       json
// @Produce      json
// @Param        currency body  model.Currency true "New custom currency"
// @Success      200  {object}  model.Currency "Saved custom currency"
// @Failure      400  {object}  dao.Error      "Malformed currency structure"
// @Failure      409  {object}  dao.Error      "Currency already exists"
// @Failure      500  {object}  dao.Error      "Internal server error"
// @Router       /currency [post]
func NewCurrency(c *fiber.Ctx) error {

	// Marshal json body to struct
	var currency model.Currency

	// Workaround caused by malformed jsons generated by some frameworks like angular that omits spaces after :
	decoder := json.NewDecoder(bytes.NewReader(c.Body()))
	if err := decoder.Decode(&currency); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(dao.NewMultipleErrors(
			"request body should be a JSON object", err))
	}

	// Force to be a custom currency
	currency.Type = model.CustomCurrency

	// Persist
	if err := currency.New(); err != nil {
		return c.Status(err.StatusCode).JSON(err)
	}

	return c.Status(fiber.StatusOK).JSON(currency)
}

// UpdateCurrency Updates a custom currency
// @Summary      Updates a custom currency
// @Description  Execute a custom currency update
// @Tags         currency
// @Accept       json
// @Produce      json
// @Param        code path string true "Currency code"
// @Param        currency body model.Currency true "New custom currency"
// @Success      200  {object}  model.Currency "Saved custom currency"
// @Failure      400  {object}  dao.Error      "Malformed currency structure"
// @Failure      403  {object}  dao.Error      "Currency or field not allowed to be update"
// @Failure      404  {object}  dao.Error      "Currency not fount"
// @Failure      500  {object}  dao.Error      "Internal server error"
// @Router       /currency/{code} [put]
func UpdateCurrency(c *fiber.Ctx) error {

	// Workaround caused by malformed jsons generated by some frameworks like angular that omits spaces after :
	var currency model.Currency
	decoder := json.NewDecoder(bytes.NewReader(c.Body()))
	if err := decoder.Decode(&currency); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(dao.NewMultipleErrors(
			"request body should be a JSON object", err))
	}

	// Get currency code from URL
	if currency.Code != strings.ToUpper(strings.TrimSpace(c.Params("symbol", ""))) {
		return c.Status(fiber.StatusForbidden).JSON(dao.Error{Message: "currency code cannot be modified, please delete and create a new one"})
	}

	// Load currency from database/cache
	dbCurrency := model.Currency{Code: currency.Code}
	if err := dbCurrency.Load(); err != nil {
		return c.Status(err.StatusCode).JSON(err)
	}

	// Check if the currency is a custom currency
	if dbCurrency.Type != model.CustomCurrency {
		return c.Status(fiber.StatusForbidden).JSON(dao.Error{Message: "only custom currencies can be modified"})
	}

	// Force to be a custom currency
	currency.Type = model.CustomCurrency

	// Save edits
	if err := currency.Save(); err != nil {
		return c.Status(err.StatusCode).JSON(err)
	}

	return c.Status(fiber.StatusOK).JSON(currency)
}

// DeleteCurrency Deletes a custom currency
// @Summary      Deletes a custom currency
// @Description  Execute a custom currency deletion
// @Tags         currency
// @Produce      json
// @Param        code path string true "Currency code"
// @Success      200  {object}  server.SuccessResponse "Custom currency successfully deleted"
// @Failure      403  {object}  dao.Error              "Currency not allowed to deletion"
// @Failure      404  {object}  dao.Error              "Currency not fount"
// @Failure      405  {object}  dao.Error              "Not allowed to delete all currencies"
// @Failure      500  {object}  dao.Error              "Internal server error"
// @Router       /currency/{code} [delete]
func DeleteCurrency(c *fiber.Ctx) error {

	// Creates currency entity using path parameter
	currency := model.Currency{
		Code: strings.ToUpper(strings.TrimSpace(c.Params("symbol", ""))),
	}

	// Load the currency from cache/database
	if err := currency.Load(); err != nil {
		return c.Status(err.StatusCode).JSON(err)
	}

	// Only allow delete custom currencies
	if currency.Type != model.CustomCurrency {
		return c.Status(fiber.StatusForbidden).JSON(dao.Error{Message: "only custom currencies can be deleted"})
	}

	// Delete currency entity
	if err := currency.Delete(); err != nil {
		return c.Status(err.StatusCode).JSON(err)
	}

	// Returns success
	return c.Status(fiber.StatusOK).JSON(SuccessResponse{true})
}

// GetCurrencyList Reads all currencies
// @Summary     Reads all currencies
// @Description Reads all currencies
// @Tags         currency
// @Produce      json
// @Success      200  {object}  []model.Currency "Currency list"
// @Failure      500  {object}  dao.Error      "Internal server error"
// @Router       /currency [get]
func GetCurrencyList(c *fiber.Ctx) error {
	return GetCurrency(c)
}

// GetCurrency   Reads a single
// @Summary      Reads a single
// @Description  Reads a single
// @Tags         currency
// @Produce      json
// @Param        code path string true "Currency code"
// @Success      200  {object}  model.Currency   "Currency"
// @Failure      404  {object}  dao.Error      "Currency not fount"
// @Failure      500  {object}  dao.Error      "Internal server error"
// @Router       /currency/{code} [get]
func GetCurrency(c *fiber.Ctx) error {

	// Creates currency entity using path parameter
	currency := model.Currency{
		Code: strings.ToUpper(strings.TrimSpace(c.Params("symbol", ""))),
	}

	// If is an empty currency code list all entities else get the supplied currency
	var err *dao.Error
	if currency.Code != "" {
		err = currency.Load()
		if err == nil {
			return c.Status(fiber.StatusOK).JSON(currency)
		}
	} else {
		var currencies []*model.Currency
		err = currency.List(&currencies)
		if err == nil {
			return c.Status(fiber.StatusOK).JSON(currencies)
		}
	}
	return c.Status(err.StatusCode).JSON(err)
}
